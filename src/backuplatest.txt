#include <SPI.h>
#include <lorawan.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Wire.h>
#include <lvgl.h>
#include <TFT_eSPI.h>
#include <TinyGPSPlus.h>
#include <SoftwareSerial.h>
#include <AntaresESPHTTP.h>
#include "OneButton.h"
#include <masonkresge_s-falldetector_inferencing.h>

// ABP Credentials
const char *devAddr = "eb56ad41";
const char *nwkSKey = "c54480b0119182c69b5867fc9046233a";
const char *appSKey = "6b15dcf8e8686605d6a42f52a5f74c35";

const unsigned long interval = 5000;      // 5s interval to send message
unsigned long previousMillis = 0;         // will store last time message sent
const unsigned long LoRainterval = 60000; // interval to send LoRa message
unsigned long LoRapreviousMillis = 0;     // will store last time message sent
unsigned int transmission = 0;            // message counter

char myStr[50];
char myStr2[50];
char myStr3[10];
byte outStr[255];
byte recvStatus = 0;
int port, channel, freq;
bool newmessage = false;
volatile int isArrived = 0;
int fallCounter = 0;
String inferencingResult = "";

const sRFM_pins RFM_pins = {
    .CS = 34,
    .RST = 33,
    .DIO0 = 38,
    .DIO1 = 48,
};

#define PIN_BAT_VOLT 4
#define PIN_BTN_L 0
#define PIN_BTN_R 47
#define PIN_LCD_BL 10

#define IMU_SDA 16
#define IMU_SCL 39

#define GPS_RX 18
#define GPS_TX 17

#define ACCESSKEY "958a12ce6d1be97d:f23149f4927ba5ba" // Replace with your Antares account access key
#define WIFISSID "BenS9"                              // Replace with your Wi-Fi SSID
#define PASSWORD "fqkj4876"                           // Replace with your Wi-Fi password

#define projectName "SafeTrack" // Replace with the Antares application name that was created
#define deviceName "ChildGPS"   // Replace with the Antares device name that was created

#define FREQUENCY_HZ EI_CLASSIFIER_FREQUENCY
#define INTERVAL_MS (1000 / (FREQUENCY_HZ + 1))
float features[EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE];
size_t feature_ix = 0;

AntaresESPHTTP antares(ACCESSKEY);
Adafruit_MPU6050 myIMU;
TinyGPSPlus gps;
lv_obj_t *label;
OneButton btn_left(PIN_BTN_L, true);
OneButton btn_right(PIN_BTN_R, true);

// Global variable to store connection status
volatile int wifiConnected = 0; // 1: Connected, 0: Not Connected
volatile int sendRequest = 0;

/*Change to your screen resolution*/
static const uint16_t screenWidth = 128;
static const uint16_t screenHeight = 128;

static lv_disp_draw_buf_t draw_buf;
static lv_color_t buf[screenWidth * 10];

TFT_eSPI tft = TFT_eSPI(screenWidth, screenHeight); /* TFT instance */

SPIClass loraSPI(VSPI); // Create a new SPI instance for LoRa

// The serial connection to the GPS device
SoftwareSerial ss(GPS_RX, GPS_TX);

// Duration for faint check in milliseconds
#define FAINT_CHECK_DURATION_MS 60000
// Sampling interval
#define SAMPLING_INTERVAL_MS 100
volatile int faintWatch = 0; // Global variable to trigger faint check

// Global variables for sharing data between tasks
float ax, ay, az, volt;
float latitude = 0.0, longitude = 0.0;
float LoRalat = 0.0, LoRalon = 0.0;
String LoRatime = "N/A";
String GPStime = "N/A";

#if LV_USE_LOG != 0
/* Serial debugging */
void my_print(const char *buf)
{
    Serial.printf(buf);
    Serial.flush();
}
#endif

/* Display flushing */
void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)
{
    uint32_t w = (area->x2 - area->x1 + 1);
    uint32_t h = (area->y2 - area->y1 + 1);

    tft.startWrite();
    tft.setAddrWindow(area->x1, area->y1, w, h);
    tft.pushColors((uint16_t *)&color_p->full, w * h, false);
    tft.endWrite();

    lv_disp_flush_ready(disp);
}

void checkLoRaRX()
{
    // Check for incoming data
    lora.update();

    // Read the data into outStr and store the number of bytes received
    int recvStatus = lora.readDataByte(outStr);

    if (recvStatus)
    {
        // If new data is received, check if it's the "arrived" message
        String receivedMessage = "";

        // Convert the received bytes to a string
        for (int i = 0; i < recvStatus; i++)
        {
            receivedMessage += char(outStr[i]);
        }

        // Check if the received message is "arrived"
        if (receivedMessage == "Arrived")
        {
            Serial.println("Arrived");
            isArrived = 1;
        }
    }
}

void sendLoRaGPS(void *pvParameters)
{
    for (;;)
    {
        if (sendRequest == 1 && millis() - LoRapreviousMillis > LoRainterval)
        {
            lora.setNwkSKey(nwkSKey);
            lora.setAppSKey(appSKey);
            lora.setDevAddr(devAddr);
            LoRapreviousMillis = millis();
            sendRequest = 0;
            sprintf(myStr, "{\"lat\":%.6f,\"lon\":%.6f,\"t\":\"%s\"}", LoRalat, LoRalon, LoRatime.c_str());
            lora.sendUplink(myStr, strlen(myStr), 0);
            transmission++;
            checkLoRaRX();
        }
        vTaskDelay(5000 / portTICK_PERIOD_MS); // Delay for 5 seconds
    }
}

void internetCheck()
{
    // Update the global variable based on Wi-Fi connection status
    if (WiFi.status() == WL_CONNECTED)
    {
        wifiConnected = 1; // Connected
    }
    else
    {
        wifiConnected = 0; // Not Connected
    }
}

void acknowledge()
{
    const char *devAddrapp = "09d39d8a";
    const char *nwkSKeyapp = "5c4edcb2c717f8c20c7dfe492a89fe7d";
    const char *appSKeyapp = "8f918cd5bba03665da4be60297d465e8";
    if (isArrived == 1)
    {
        isArrived = 0;
        if (wifiConnected == 0)
        {
            sprintf(myStr3, "{\"location\":acknowledged\"}");
            lora.setDevAddr(devAddrapp);
            lora.setNwkSKey(nwkSKeyapp);
            lora.setAppSKey(appSKeyapp);
            lora.sendUplink(myStr3, strlen(myStr3), 0);
        }
        else
        {
            antares.add("location", "acknowledged");
            antares.send(projectName, "PickupNotification");
        }
    }
    else
    {
        return;
    }
}

void sendAlert(String type)
{
    const char *devAddrfall = "307b448b";
    const char *nwkSKeyfall = "6b32d434f7b90fb9e3701d4af6574240";
    const char *appSKeyfall = "8a40485d8edfe11439c36c852cf281fe";
    if (WiFi.status() != WL_CONNECTED)
    {
        sprintf(myStr2, "{\"lat\":%.6f,\"lon\":%.6f,\"t\":\"%s,\"type\":\"%s\"}", latitude, longitude, GPStime.c_str(), type.c_str());
        lora.setDevAddr(devAddrfall);
        lora.setNwkSKey(nwkSKeyfall);
        lora.setAppSKey(appSKeyfall);
        lora.sendUplink(myStr2, strlen(myStr2), 0);
    }
    else
    {
        antares.add("data", "lat", latitude);
        antares.add("data", "lon", longitude);
        antares.add("data", "t", GPStime.c_str());
        antares.add("data", "type", type);
        antares.send(projectName, "FallAlert");
    }
}

// Helper function to calculate total acceleration magnitude
float calculateAccelerationMagnitude(float x, float y, float z)
{
    return sqrt(x * x + y * y + z * z);
}

void faintCheck(void *pvParameters)
{
    const float JERK_THRESHOLD = 25;    // Adjust based on your application
    const int SAMPLE_INTERVAL_MS = 100; // Sampling interval
    unsigned long startTime = millis();
    bool fainted = true;

    // Previous acceleration values
    float prevAccX = 0.0, prevAccY = 0.0, prevAccZ = 0.0;

    Serial.println("Faint Check Task started.");

    while (1)
    {
        // Convert accelerometer readings from m/s² to g (1 g = 9.8 m/s²)
        float acceleration_g_x = ax;
        float acceleration_g_y = ay;
        float acceleration_g_z = az;

        // Calculate jerk (change in acceleration over time)
        float jerkX = (acceleration_g_x - prevAccX) / (SAMPLE_INTERVAL_MS / 1000.0);
        float jerkY = (acceleration_g_y - prevAccY) / (SAMPLE_INTERVAL_MS / 1000.0);
        float jerkZ = (acceleration_g_z - prevAccZ) / (SAMPLE_INTERVAL_MS / 1000.0);

        // Update previous acceleration values
        prevAccX = acceleration_g_x;
        prevAccY = acceleration_g_y;
        prevAccZ = acceleration_g_z;

        // Calculate the magnitude of jerk
        float jerkMagnitude = sqrt(jerkX * jerkX + jerkY * jerkY + jerkZ * jerkZ);

        // Log data for debugging
        Serial.print("Jerk Magnitude: ");
        Serial.println(jerkMagnitude);

        // Check if the jerk magnitude exceeds the threshold
        if (jerkMagnitude > JERK_THRESHOLD)
        {
            Serial.println("Significant movement detected. Resetting faintWatch to 0.");
            faintWatch = 0;
            vTaskDelete(NULL); // Stop the task
        }

        // Check if 60 seconds have passed
        if (millis() - startTime >= FAINT_CHECK_DURATION_MS)
        {
            Serial.println("No significant movement detected for 60 seconds. User has fainted.");
            sendAlert("pingsan");
            faintWatch = 0;    // Reset faintWatch after the check
            vTaskDelete(NULL); // Stop the task
        }

        // Wait for the next sample
        vTaskDelay(SAMPLE_INTERVAL_MS / portTICK_PERIOD_MS);
    }
}

// Monitor task to detect faintWatch activation
void monitorFaintWatch(void *pvParameters)
{
    while (1)
    {
        if (faintWatch == 1)
        {
            Serial.println("faintWatch set to 1. Waiting for 6 seconds...");
            vTaskDelay(6000 / portTICK_PERIOD_MS); // Wait for 6 seconds

            // Create the faintCheck task
            xTaskCreatePinnedToCore(
                faintCheck,   // Task function
                "FaintCheck", // Task name
                4096,         // Stack size in words
                NULL,         // Task parameters
                1,            // Task priority
                NULL,         // Task handle
                1);

            // Reset faintWatch to prevent multiple triggers
            faintWatch = 0;
        }

        // Yield to other tasks
        vTaskDelay(100 / portTICK_PERIOD_MS); // Check faintWatch every 100ms
    }
}

void checkArrivalTask(void *pvParameters)
{
    for (;;)
    {
        if (WiFi.status() == WL_CONNECTED)
        {
            antares.get(projectName, "PickupNotification");
            if (antares.getSuccess())
            {
                String received = antares.getString("location");
                Serial.println(received);
                if (received == "Arrived")
                {
                    isArrived = 1;
                }
            }
        }
        vTaskDelay(10000 / portTICK_PERIOD_MS);
    }
}

void imuTask(void *pvParameters)
{
    unsigned long last_interval_ms = 0;

    while (1)
    {
        // float x, y, z;
        // Check if it's time to sample
        if (millis() - last_interval_ms >= INTERVAL_MS)
        {
            last_interval_ms = millis();

            // Read accelerometer data
            sensors_event_t a, g, temp;
            myIMU.getEvent(&a, &g, &temp);

            ax = a.acceleration.x;
            ay = a.acceleration.y;
            az = a.acceleration.z;

            // Add accelerometer data to features buffer
            features[feature_ix++] = a.acceleration.y;
            features[feature_ix++] = a.acceleration.x;
            features[feature_ix++] = a.acceleration.z;

            // Check if features buffer is full
            if (feature_ix >= EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE)
            {
                feature_ix = 0;

                // Create the signal for inference
                signal_t signal;
                numpy::signal_from_buffer(features, EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE, &signal);

                // Run inference
                ei_impulse_result_t result;
                EI_IMPULSE_ERROR err = run_classifier(&signal, &result);

                if (err == EI_IMPULSE_OK)
                {
                    // Find the label with the highest probability
                    float maxValue = 0.0f;
                    int maxIndex = 0;

                    for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++)
                    {
                        if (result.classification[ix].value > maxValue)
                        {
                            maxValue = result.classification[ix].value;
                            maxIndex = ix;
                        }
                    }

                    // Update the global variable with the highest-valued label
                    inferencingResult = result.classification[maxIndex].label;
                    if (inferencingResult == "Fall")
                    {
                        fallCounter++;
                        if (fallCounter == 4)
                        {
                            sendAlert("terjatuh");
                            faintWatch = 1;
                            fallCounter = 0; // Reset the counter after detection
                        }
                    }
                    else
                    {
                        fallCounter = 0; // Reset the counter if the label is not "Fall"
                    }
                }
                else
                {
                    Serial.print("Error running classifier: ");
                    Serial.println(err);
                }
            }
        }
        // Allow other tasks to run
        vTaskDelay(1 / portTICK_PERIOD_MS);
    }
}

void gpsTask(void *pvParameters)
{
    // Variables to store the last three sets of latitude and longitude values
    float lastLat[3] = {0.0, 0.0, 0.0};
    float lastLon[3] = {0.0, 0.0, 0.0};
    int sameDataCount = 0;
    for (;;)
    {
        // Read GPS data
        while (ss.available() > 0)
        {
            char c = ss.read();
            gps.encode(c);
            Serial.print(c); // Debug line to print raw GPS data

            if (gps.location.isUpdated())
            {
                latitude = gps.location.lat();
                longitude = gps.location.lng();
            }

            if (gps.time.isValid())
            {
                int hour = gps.time.hour();
                int minute = gps.time.minute();
                int second = gps.time.second();

                // Adjust to GMT+7
                hour += 7;
                if (hour >= 24)
                {
                    hour -= 24;
                }

                GPStime = String(hour) + ":" + String(minute) + ":" + String(second);
            }
            else
            {
                GPStime = "N/A";
            }
        }
        if (millis() - previousMillis > interval)
        {
            previousMillis = millis();
            // Check if the current data matches the previous three sets
            if (latitude == lastLat[0] && latitude == lastLat[1] && latitude == lastLat[2] &&
                longitude == lastLon[0] && longitude == lastLon[1] && longitude == lastLon[2])
            {
                sameDataCount++;
            }
            else
            {
                sameDataCount = 0;
            }

            // If the data is the same three times in a row, skip sending
            if (sameDataCount < 3)
            {

                if (WiFi.status() == WL_CONNECTED && sendRequest != 1)
                {
                    LoRalat = latitude;
                    LoRalon = longitude;
                    LoRatime = GPStime;
                    sendRequest = 1;
                }
                else if (latitude != 0.0 && longitude != 0.0)
                {
                    antares.add("data", "lat", latitude);
                    antares.add("data", "lon", longitude);
                    antares.add("data", "t", GPStime.c_str());
                    antares.send(projectName, deviceName);
                    transmission++;
                }

                // Update the last three sets of latitude and longitude values
                lastLat[2] = lastLat[1];
                lastLat[1] = lastLat[0];
                lastLat[0] = latitude;

                lastLon[2] = lastLon[1];
                lastLon[1] = lastLon[0];
                lastLon[0] = longitude;
            }
        }

        vTaskDelay(100 / portTICK_PERIOD_MS); // Delay for 100 ms
    }
}

void displayTask(void *pvParameters)
{
    for (;;)
    {
        wifiConnected = WiFi.status() == WL_CONNECTED ? 1 : 0;
        volt = (analogRead(PIN_BAT_VOLT) * 2 * 3.3) / 4096;
        lv_label_set_text_fmt(label, "%.2f %.2f %.2f\nval:%s\nLat:%.6f\nLon:%.6f\nTime:%s\nbat:%.2fv wifi:%d\nsent:%d Arrived:%d\n fwatch:%d",
                              ax, ay, az, inferencingResult.c_str(), latitude, longitude, GPStime.c_str(), volt, wifiConnected, transmission, isArrived, faintWatch);

        lv_timer_handler();                   /* let the GUI do its work */
        vTaskDelay(100 / portTICK_PERIOD_MS); // Update display every 100 ms
    }
}

void go_to_sleep(void)
{
    Serial.println("sleep");

    // High level off the backlight
    digitalWrite(PIN_LCD_BL, HIGH);
    // Enable backlight hold on high level
    gpio_hold_en((gpio_num_t)PIN_LCD_BL);

    // IO47 cannot be set to the source of the awakening,
    // and can only be set to GPIO0 as the keys to wake the source
#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 6)
    esp_sleep_enable_ext1_wakeup(GPIO_SEL_0, ESP_EXT1_WAKEUP_ANY_LOW);
#else
    esp_sleep_enable_ext1_wakeup(GPIO_SEL_0, ESP_EXT1_WAKEUP_ALL_LOW);
#endif

    esp_deep_sleep_start();
}

void setup()
{
    Serial.begin(115200);

    gpio_hold_dis((gpio_num_t)PIN_LCD_BL);
    pinMode(PIN_BAT_VOLT, ANALOG);
    btn_left.attachClick(go_to_sleep);
    btn_right.attachClick(acknowledge);

    antares.wifiConnection(WIFISSID, PASSWORD);
    antares.setDebug(true);

    Wire.begin(IMU_SDA, IMU_SCL);
    if (!myIMU.begin())
    {
        Serial.println("Failed to find MPU6050 chip");
        while (1)
        {
            delay(10);
        }
    }
    myIMU.setFilterBandwidth(MPU6050_BAND_21_HZ);
    Serial.println(F("MPU6050 initialized"));

    // Initialize LVGL
    lv_init();
    tft.begin();
    tft.setRotation(1);
    lv_disp_draw_buf_init(&draw_buf, buf, NULL, screenWidth * 10);
    static lv_disp_drv_t disp_drv;
    lv_disp_drv_init(&disp_drv);
    disp_drv.hor_res = screenWidth;
    disp_drv.ver_res = screenHeight;
    disp_drv.flush_cb = my_disp_flush;
    disp_drv.draw_buf = &draw_buf;
    lv_disp_drv_register(&disp_drv);
    label = lv_label_create(lv_scr_act());
    lv_label_set_text(label, "MPU6050 and GPS Data");

    // Initialize GPS
    ss.begin(9600);

    // Setup LoRaWAN
    loraSPI.begin(36, 37, 35); // SCK, MISO, MOSI for LoRa
    delay(2000);
    if (!lora.init())
    {
        Serial.println("RFM95 not detected");
        delay(5000);
        return;
    }

    lora.setDeviceClass(CLASS_A);
    lora.setDataRate(SF10BW125);
    lora.setFramePortTx(5);
    lora.setChannel(MULTI);
    lora.setTxPower(17);
    lora.setNwkSKey(nwkSKey);
    lora.setAppSKey(appSKey);
    lora.setDevAddr(devAddr);

    // Create tasks
    xTaskCreatePinnedToCore(
        sendLoRaGPS,   // Function to implement the task
        "SendLoRaGPS", // Name of the task
        4096,          // Stack size in words
        NULL,          // Task input parameter
        1,             // Priority of the task
        NULL,          // Task handle
        1);            // Core where the task should run

    xTaskCreatePinnedToCore(
        checkArrivalTask,   // Function to implement the task
        "CheckArrivalTask", // Name of the task
        4096,               // Stack size in words
        NULL,               // Task input parameter
        2,                  // Priority of the task
        NULL,               // Task handle
        0);                 // Core where the task should run

    xTaskCreatePinnedToCore(
        displayTask,   // Function to implement the task
        "DisplayTask", // Name of the task
        3048,          // Stack size in words
        NULL,          // Task input parameter
        1,             // Priority of the task
        NULL,          // Task handle
        0);            // Core where the task should run

    xTaskCreatePinnedToCore(
        imuTask,   // Function to implement the task
        "IMUTask", // Name of the task
        4096,      // Stack size in words
        NULL,      // Task input parameter
        3,         // Priority of the task
        NULL,      // Task handle
        1);        // Core where the task should run

    xTaskCreatePinnedToCore(
        gpsTask,   // Function to implement the task
        "GPSTask", // Name of the task
        8192,      // Stack size in words
        NULL,      // Task input parameter
        3,         // Priority of the task
        NULL,      // Task handle
        0);        // Core where the task should run

    xTaskCreatePinnedToCore(
        monitorFaintWatch,         // Task function
        "Monitor FaintWatch Task", // Task name
        1024,                      // Stack size in words
        NULL,                      // Task parameters
        1,                         // Task priority
        NULL,                      // Task handle
        1);
}

void loop()
{
    btn_left.tick();
    btn_right.tick();
}
